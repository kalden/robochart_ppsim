package autogenerated_sim;

import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;

public class LTiModule implements Steppable, Stoppable {

	private LTiController LTiModule_LTiController;
	private LTiStep LTiModule_LTiStep;
	
	// For MASON specific sims, need these attributes
	/**
	 * Flag to show that the LTo has been removed as this did not differentiate by a set time
	 */
	public boolean stopped = false;
		
	// KA: For MASON we need to be able to stop the cell, so the below needs to be added
	/**
	 * Flag to show if this class has been stopped (when no longer needed)
	 */
	public Stoppable stopper = null;
	    
	/**
	 * Method to change the value of the stopper
	 * @param stopper	Whether the class should be stopped or not
	 */
	public void setStopper(Stoppable stopper)   {this.stopper = stopper;}
	    
	/**
	* Method to stop the class where necessary
	*/
	public void stop(){
		stopped = true;
	   	stopper.stop();
	}
	
	/**
	* Getter for robotic platform containing the step
	*/ 
	

	public LTiModule()
	{
		this.LTiModule_LTiController = null;
		
		
		// KA: Moved Robotic Platform into constructor, as needs to be initialised before state machine	
	this.LTiModule_LTiStep = new LTiStep ();
		
		}


public LTiStep getLTiModule_LTiStep()
{
	return this.LTiModule_LTiStep;
}

	public void Init() {
		this.LTiModule_LTiController = new LTiController (LTiModule_LTiStep);
		LTi_State_Machine LTiController_LTi_State_Machine = new LTi_State_Machine(LTiModule_LTiStep, LTiModule_LTiController);
		LTiModule_LTiController.stm = LTiController_LTi_State_Machine;
	}

	public void Execute() {
		this.LTiModule_LTiStep.Sensors();
		this.LTiModule_LTiController.Execute();
		this.LTiModule_LTiStep.Actuators();
	}

	
	public void step(SimState state)
	{
		// MASON step method. Should call Execute, but may do other operations that need specifying in here
		Execute();
	}
	
	// If outputting the simulation as a GUI, draw function is also required here
	}
